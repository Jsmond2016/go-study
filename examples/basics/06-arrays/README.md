# 数组示例

本示例展示了 Go 语言中数组的使用方法和特性。

## 运行示例

```bash
go run main.go
```

## 知识点

### 1. 数组基本特性

- **固定长度**：数组长度在声明时确定，不能改变
- **值类型**：数组是值类型，赋值和传递时会复制整个数组
- **连续内存**：数组元素在内存中连续存储
- **类型安全**：数组的类型包括长度和元素类型

### 2. 数组声明和初始化

```go
// 声明方式
var arr1 [5]int                    // 零值数组
var arr2 = [5]int{1, 2, 3, 4, 5}  // 完全初始化
arr3 := [5]int{10, 20, 30}         // 部分初始化，其余为零值
arr4 := [...]int{1, 2, 3, 4, 5}    // 编译器推断长度
arr5 := [5]int{0: 100, 4: 500}     // 指定索引初始化
```

### 3. 数组操作

```go
// 访问元素
value := arr[0]
arr[1] = 100

// 获取长度
length := len(arr)

// 数组比较（相同类型和长度）
equal := arr1 == arr2
```

### 4. 数组遍历

```go
// 传统循环
for i := 0; i < len(arr); i++ {
    fmt.Printf("索引 %d: 值 %v\n", i, arr[i])
}

// for-range 循环
for index, value := range arr {
    fmt.Printf("索引 %d: 值 %v\n", index, value)
}
```

### 5. 多维数组

```go
// 二维数组
var matrix [3][4]int

// 初始化二维数组
matrix := [3][4]int{
    {1, 2, 3, 4},
    {5, 6, 7, 8},
    {9, 10, 11, 12},
}

// 访问元素
value := matrix[1][2]
```

### 6. 数组作为参数

```go
// 值传递（不会修改原数组）
func modifyArray(arr [5]int) {
    arr[0] = 100
}

// 指针传递（会修改原数组）
func modifyArrayPtr(arrPtr *[5]int) {
    (*arrPtr)[0] = 100
}
```

## 重要概念

### 1. 值类型特性

数组是值类型，这意味着：
- 赋值操作会复制整个数组
- 函数参数传递会复制整个数组
- 修改副本不会影响原数组

### 2. 性能考虑

- 大数组的复制成本较高
- 对于大数据集合，考虑使用切片
- 数组访问速度比切片快

### 3. 数组 vs 切片

| 特性 | 数组 | 切片 |
|------|------|------|
| 长度 | 固定 | 可变 |
| 传递方式 | 值传递 | 引用传递 |
| 性能 | 访问快 | 灵活性高 |
| 使用场景 | 固定大小数据 | 动态数据集合 |

## 使用场景

1. **固定大小的数据集合**：一周7天、一年12个月
2. **矩阵运算**：二维或三维数组
3. **缓冲区**：固定大小的数据缓冲区
4. **性能关键场景**：需要确定内存布局
5. **与C语言交互**：数组布局与C数组兼容

## 最佳实践

1. **优先使用切片**：对于大多数情况，切片更灵活
2. **明确数组大小**：使用常量定义数组大小
3. **避免大数组复制**：大数组使用指针传递
4. **利用零值**：利用数组的零值初始化特性

## 常见陷阱

1. **数组长度不匹配**：不同长度的数组是不同类型
2. **意外的大数组复制**：注意函数调用的性能影响
3. **索引越界**：访问数组索引要检查边界
4. **初始化混淆**：理解各种初始化语法的区别

## 练习

1. 实现矩阵加法和乘法
2. 创建一个简单的井字棋游戏
3. 实现数组的排序算法
4. 使用数组实现一个简单的缓冲区
5. 创建一个学生成绩管理系统